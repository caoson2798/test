<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Friends Map">
  <link rel="apple-touch-icon" href="ava.png">
  <link rel="apple-touch-icon" sizes="180x180" href="icons/icon-180.png">
  <link rel="apple-touch-icon" sizes="152x152" href="icons/icon-152.png">
  <link rel="apple-touch-icon" sizes="120x120" href="icons/icon-120.png">
  <link rel="manifest" href="manifest.json">

  <title>Friends Map</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&display=swap" rel="stylesheet">

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    :root{
      --bg-color:#f8fafc;
      --glass-bg:rgba(255,255,255,0.85);
      --glass-border:rgba(0,0,0,0.08);
      --primary:#2563eb;
      --primary-glow:rgba(37,99,235,0.3);
      --text-main:#0f172a;
      --text-muted:#64748b;
      --danger:#ef4444;
      --success:#16a34a;
      --radius:16px;
      --safe-b: env(safe-area-inset-bottom, 20px);
      --safe-t: env(safe-area-inset-top, 20px);
    }
    *{box-sizing:border-box;-webkit-tap-highlight-color:transparent;}
    body{
      margin:0;
      font-family:'Inter',sans-serif;
      background:var(--bg-color);
      color:var(--text-main);
      height:100dvh;
      overflow:hidden;
    }
    .hidden{display:none!important;}

    .btn{
      border:none;outline:none;
      font-family:inherit;
      font-weight:600;font-size:14px;
      padding:12px 16px;border-radius:12px;
      cursor:pointer;transition:all .2s;
      display:inline-flex;align-items:center;justify-content:center;gap:8px;
    }
    .btn:active{transform:scale(.96);}
    .btn.primary{background:var(--primary);color:#fff;box-shadow:0 4px 12px var(--primary-glow);}
    .btn.secondary{background:rgba(0,0,0,0.05);color:var(--text-main);border:1px solid var(--glass-border);}
    .btn.danger{background:#fee2e2;color:#ef4444;border:1px solid #fca5a5;}
    .btn.success{background:#dcfce7;color:#16a34a;border:1px solid #86efac;}

    .inp{
      width:100%;
      background:rgba(255,255,255,0.8);
      border:1px solid #cbd5e1;
      color:var(--text-main);
      padding:14px;border-radius:12px;
      outline:none;font-size:16px;
      transition:border-color .2s;
    }
    .inp:focus{border-color:var(--primary);background:#fff;}

    .login-screen{
      height:100%;
      display:flex;flex-direction:column;
      align-items:center;justify-content:center;
      padding:20px;text-align:center;
      background:linear-gradient(135deg,#e0f2fe 0%,#f0f9ff 100%);
    }
    .login-card{
      background:rgba(255,255,255,0.6);
      backdrop-filter:blur(20px);
      -webkit-backdrop-filter:blur(20px);
      border:1px solid #fff;
      padding:32px 24px;border-radius:24px;
      width:100%;max-width:380px;
      box-shadow:0 20px 40px rgba(0,0,0,0.05);
    }
    .app-logo{
      width:64px;height:64px;
      background:linear-gradient(135deg,var(--primary),#60a5fa);
      border-radius:18px;
      display:grid;place-items:center;
      font-size:28px;font-weight:900;color:#fff;
      margin:0 auto 16px;
      box-shadow:0 10px 25px var(--primary-glow);
    }
    .login-title{font-size:22px;font-weight:800;margin:0 0 8px;}
    .login-sub{font-size:14px;color:var(--text-muted);margin-bottom:24px;line-height:1.5;}

    .app-screen{display:flex;flex-direction:column;height:100%;position:relative;}

    .topbar{
      position:absolute;top:0;left:0;right:0;z-index:1000;
      padding:calc(var(--safe-t) + 10px) 16px 12px;
      background:linear-gradient(180deg,rgba(255,255,255,0.95) 0%,rgba(255,255,255,0) 100%);
      display:flex;align-items:center;justify-content:space-between;
      pointer-events:none;
    }
    .topbar>*{pointer-events:auto;}
    .page-title{font-weight:800;font-size:20px;color:var(--text-main);text-shadow:0 0 10px #fff;}
    .user-pill{
      display:flex;align-items:center;gap:8px;
      background:rgba(255,255,255,0.8);
      backdrop-filter:blur(10px);
      padding:4px 12px 4px 4px;border-radius:30px;
      border:1px solid #fff;
      box-shadow:0 2px 10px rgba(0,0,0,0.05);
      cursor:pointer;
    }
    .user-pill img{width:24px;height:24px;border-radius:50%;object-fit:cover;}

    .content-area{flex:1;position:relative;overflow:hidden;}
    .view-container{
      position:absolute;inset:0;
      overflow-y:auto;
      padding:calc(70px + var(--safe-t)) 16px calc(140px + var(--safe-b));
      background:#f1f5f9;
    }
    #viewMap.view-container{padding:0;background:transparent;bottom:0;overflow:hidden;}
    #map{width:100%;height:100%;z-index:1;}

    .locate-btn{
      position:absolute;
      bottom:calc(96px + var(--safe-b));
      right:16px;
      z-index:999;
      width:48px;height:48px;
      background:#fff;border-radius:50%;
      box-shadow:0 4px 15px rgba(0,0,0,0.15);
      display:grid;place-items:center;
      font-size:20px;cursor:pointer;
      border:1px solid rgba(0,0,0,0.05);
    }
    .locate-btn:active{transform:scale(.9);}

    .route-btn{
      position:absolute;
      bottom:calc(96px + var(--safe-b));
      left:16px;
      z-index:999;
      display:flex;gap:10px;
    }

    .glass-card{
      background:rgba(255,255,255,0.75);
      backdrop-filter:blur(16px);
      -webkit-backdrop-filter:blur(16px);
      border:1px solid #fff;
      border-radius:var(--radius);
      padding:16px;margin-bottom:16px;
      box-shadow:0 4px 6px -1px rgba(0,0,0,0.05);
    }
    .card-head{font-size:16px;font-weight:700;margin-bottom:12px;display:flex;justify-content:space-between;align-items:center;}

    .list-item{
      display:flex;align-items:center;justify-content:space-between;
      padding:12px;background:rgba(255,255,255,0.6);
      border:1px solid #fff;border-radius:12px;
      margin-bottom:8px;gap:10px;
    }
    .list-left{display:flex;align-items:center;gap:10px;min-width:0;}
    .list-ava{width:34px;height:34px;border-radius:50%;background:#e2e8f0;flex:0 0 auto;object-fit:cover;}
    .list-info{min-width:0;}
    .list-info b{display:block;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
    .list-info small{display:block;color:var(--text-muted);font-size:11px;margin-top:2px;}

    .friend-check{
      width:18px;height:18px;
      accent-color: var(--primary);
      flex:0 0 auto;
    }

    .profile-header{display:flex;flex-direction:column;align-items:center;text-align:center;padding:20px 0;}
    .profile-avatar{
      width:80px;height:80px;border-radius:50%;
      border:3px solid #fff;
      box-shadow:0 10px 20px rgba(0,0,0,0.1);
      margin-bottom:12px;object-fit:cover;
    }
    .profile-name{font-size:18px;font-weight:800;}
    .profile-email{color:var(--text-muted);font-size:13px;}

    .bottom-nav{
      position:absolute;
      left:12px; right:12px;
      bottom:calc(var(--safe-b) + 10px);
      padding:10px 12px;
      background:var(--glass-bg);
      backdrop-filter:blur(20px);
      -webkit-backdrop-filter:blur(20px);
      border:1px solid var(--glass-border);
      border-radius:18px;
      display:flex;justify-content:space-around;
      z-index:1000;
      box-shadow:0 10px 30px rgba(0,0,0,0.08);
    }
    .nav-item{
      display:flex;flex-direction:column;align-items:center;gap:4px;
      color:#94a3b8;
      font-size:10px;font-weight:600;
      padding:6px 16px;border-radius:12px;
      cursor:pointer;transition:all .2s;
    }
    .nav-icon{font-size:20px;margin-bottom:2px;filter:grayscale(100%);transition:.2s;}
    .nav-item.active{color:var(--primary);background:#eff6ff;}
    .nav-item.active .nav-icon{filter:grayscale(0%);}

    .toast{
      position:fixed;top:20px;left:50%;
      transform:translateX(-50%) translateY(-20px);
      background:rgba(0,0,0,0.8);
      color:#fff;padding:12px 20px;border-radius:30px;
      font-size:14px;font-weight:500;
      opacity:0;pointer-events:none;
      transition:all .3s cubic-bezier(0.175,0.885,0.32,1.275);
      z-index:9999;white-space:nowrap;
    }
    .toast.show{opacity:1;transform:translateX(-50%) translateY(calc(var(--safe-t) + 10px));}

    .avatar-marker{background:transparent;border:none;}
    .avatar-wrap{
      width:44px;height:44px;border-radius:50%;
      overflow:hidden;box-shadow:0 8px 18px rgba(0,0,0,0.22);
      position:relative;
    }
    .avatar-wrap img{width:100%;height:100%;object-fit:cover;display:block;}
    .ring-me{border:3px solid #ef4444;}
    .ring-friend{border:3px solid #2563eb;}
    .ring-off{border:3px solid #94a3b8;opacity:.85;}

    .modal-backdrop{
      position:fixed;inset:0;
      background:rgba(15,23,42,0.35);
      backdrop-filter:blur(6px);
      display:none;z-index:20000;
    }
    .modal-backdrop.show{display:block;}
    .chat-modal{
      position:absolute;left:50%;top:50%;
      transform:translate(-50%,-50%);
      width:min(520px,calc(100vw - 24px));
      height:min(78vh,680px);
      background:rgba(255,255,255,0.92);
      border:1px solid rgba(255,255,255,0.9);
      border-radius:20px;overflow:hidden;
      box-shadow:0 25px 60px rgba(0,0,0,0.25);
      display:flex;flex-direction:column;
    }
    .chat-head{
      padding:12px;
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      border-bottom:1px solid rgba(0,0,0,0.06);
      background:rgba(255,255,255,0.9);
    }
    .chat-head-left{display:flex;align-items:center;gap:10px;min-width:0;}
    .chat-ava{width:34px;height:34px;border-radius:50%;object-fit:cover;background:#e2e8f0;}
    .chat-title{font-weight:800;font-size:14px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
    .chat-sub{font-size:11px;color:var(--text-muted);margin-top:2px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}

    .chip{
      font-size:11px;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid rgba(0,0,0,0.08);
      background:rgba(255,255,255,0.7);
      color:#334155;
      font-weight:700;
      margin-left:8px;
    }

    .chat-body{
      flex:1;
      padding:12px;
      overflow-y:auto;
      background:linear-gradient(180deg,#f8fafc 0%,#f1f5f9 100%);
    }
    .msg-row{display:flex;margin:6px 0;}
    .msg-row.me{justify-content:flex-end;}
    .msg-row.other{justify-content:flex-start;}

    .msg-wrap{
      display:flex;
      flex-direction:column;
      width:fit-content;
      max-width:78%;
    }
    .msg-row.me .msg-wrap{align-items:flex-end;}
    .msg-row.other .msg-wrap{align-items:flex-start;}

    .bubble{
      display:inline-block;
      width:fit-content;
      max-width:100%;
      min-width:44px;
      padding:10px 12px;
      border-radius:16px;
      font-size:14px;
      line-height:1.35;
      box-shadow:0 6px 16px rgba(0,0,0,0.06);
      border:1px solid rgba(0,0,0,0.04);
      background:#fff;
      white-space:normal;
      overflow-wrap:anywhere;
      word-break:normal;
    }
    .msg-row.me .bubble{
      background:#dbeafe;
      border-color:rgba(37,99,235,0.18);
    }

    .msg-time{font-size:10px;color:#64748b;margin-top:4px;text-align:right;}
    .seen-line{
      padding:0 12px 10px;
      font-size:11px;
      color:#64748b;
      min-height:18px;
    }

    .chat-foot{
      padding:10px;display:flex;gap:8px;
      border-top:1px solid rgba(0,0,0,0.06);
      background:rgba(255,255,255,0.92);
    }
    .chat-input{
      flex:1;border:1px solid #cbd5e1;background:#fff;
      border-radius:14px;padding:10px 12px;outline:none;font-size:16px;
    }

    .pop{display:flex;gap:10px;align-items:center;}
    .pop img{
      width:38px;height:38px;border-radius:50%;
      object-fit:cover;background:#e2e8f0;
      border:2px solid rgba(37,99,235,0.25);
    }
    .pop b{display:block;}
    .pop small{color:#64748b;display:block;margin-top:2px;}
    .pop-actions{display:flex;gap:8px;margin-top:10px;}
    .pop-actions button{padding:8px 10px;font-size:12px;border-radius:12px;}

    @media (max-width:420px){
      .msg-wrap{max-width:86%;}
    }

    .group-actionbar{
      position:absolute;
      left:12px; right:12px;
      bottom:calc(var(--safe-b) + 86px);
      z-index:1500;
      background:rgba(255,255,255,0.92);
      border:1px solid rgba(0,0,0,0.08);
      backdrop-filter:blur(16px);
      -webkit-backdrop-filter:blur(16px);
      border-radius:18px;
      padding:10px 12px;
      display:flex;align-items:center;justify-content:space-between;gap:12px;
      box-shadow:0 10px 30px rgba(0,0,0,0.10);
    }
    .gab-left{font-size:13px;color:#0f172a;}
    .gab-left b{font-size:16px;}

    /* ‚úÖ Badge ƒë·ªè ki·ªÉu Messenger */
    .icon-btnwrap{position:relative;display:inline-flex;}
    .badge{
      position:absolute;
      top:-7px; right:-7px;
      background:#ef4444;
      color:#fff;
      border-radius:999px;
      padding:2px 6px;
      font-size:10px;
      font-weight:900;
      min-width:18px;
      text-align:center;
      border:2px solid rgba(255,255,255,0.95);
      box-shadow:0 6px 18px rgba(239,68,68,0.25);
    }

    /* ‚úÖ Loading screen */
    .loading-screen{
      height:100%;
      display:flex;flex-direction:column;
      align-items:center;justify-content:center;
      padding:20px;text-align:center;
      background:linear-gradient(135deg,#e0f2fe 0%,#f0f9ff 100%);
    }
    .spinner{
      width:42px;height:42px;
      border-radius:50%;
      border:4px solid rgba(37,99,235,0.18);
      border-top-color: rgba(37,99,235,1);
      animation:spin 0.9s linear infinite;
      margin:14px auto 10px;
    }
    @keyframes spin{to{transform:rotate(360deg);}}
  </style>
</head>

<body>
  <div id="toast" class="toast">Th√¥ng b√°o</div>

  <!-- ‚úÖ Loading (m·∫∑c ƒë·ªãnh m·ªü l√™n lu√¥n show) -->
  <section id="loadingScreen" class="loading-screen">
    <div class="login-card">
      <div class="app-logo">üó∫Ô∏è</div>
      <div class="spinner"></div>
      <h1 class="login-title" style="margin-top:8px;">ƒêang t·∫£i...</h1>
      <p class="login-sub" style="margin-bottom:0;">ƒêang x√°c nh·∫≠n ƒëƒÉng nh·∫≠p</p>
    </div>
  </section>

  <section id="loginScreen" class="login-screen hidden">
    <div class="login-card">
      <div class="app-logo">üó∫Ô∏è</div>
      <h1 class="login-title">Friends Map</h1>
      <p class="login-sub">Xem v·ªã tr√≠ b·∫°n b√® th·ªùi gian th·ª±c.<br>K·∫øt n·ªëi ngay, kh√¥ng l·∫°c l·ªëi.</p>
      <button id="btnLogin" class="btn primary" style="width:100%;height:50px;">ƒêƒÉng nh·∫≠p v·ªõi Google</button>
      <div style="margin-top:24px;font-size:12px;color:var(--text-muted);border-top:1px solid #e2e8f0;padding-top:16px;">
        *L∆∞u √Ω: N·∫øu d√πng m√°y t√≠nh b√†n, v·ªã tr√≠ c√≥ th·ªÉ kh√¥ng chu·∫©n. D√πng ƒëi·ªán tho·∫°i s·∫Ω chu·∫©n h∆°n.
      </div>
    </div>
  </section>

  <section id="appScreen" class="app-screen hidden">
    <div class="topbar">
      <div class="page-title" id="topTitle">B·∫£n ƒë·ªì</div>
      <div class="user-pill" id="btnGoProfile">
        <img id="topAvatar" src="" alt="">
        <span id="topName">Me</span>
      </div>
    </div>

    <div class="content-area">
      <div id="viewMap" class="view-container">
        <div id="map"></div>
        <div class="locate-btn" id="btnLocateMe" title="T√¨m l·∫°i v·ªã tr√≠">üéØ</div>
        <div class="route-btn">
          <button id="btnClearRoute" class="btn secondary" style="padding:10px 12px;border-radius:14px;">üßπ X√≥a ƒë∆∞·ªùng</button>
        </div>
      </div>

      <div id="viewFriends" class="view-container hidden">
        <div class="glass-card">
          <div class="card-head">‚ûï Th√™m b·∫°n m·ªõi</div>
          <input id="friendEmail" class="inp" placeholder="Nh·∫≠p email b·∫°n b√®..." style="margin-bottom:12px;" />
          <button id="btnSendRequest" class="btn primary" style="width:100%">G·ª≠i l·ªùi m·ªùi k·∫øt b·∫°n</button>
          <p class="login-sub" style="margin:8px 0 0;font-size:11px;">H·ªç ph·∫£i ƒëƒÉng nh·∫≠p app n√†y √≠t nh·∫•t 1 l·∫ßn r·ªìi m·ªõi k·∫øt b·∫°n ƒë∆∞·ª£c.</p>
        </div>

        <!-- ‚úÖ ch·ªâ gi·ªØ tick ch·ªçn -->
        <div class="glass-card">
          <div class="card-head">‚úÖ T·∫°o nh√≥m chat (tick ch·ªçn b·∫°n)</div>
          <p class="login-sub" style="margin:0;font-size:12px;">
            Tick b·∫°n ·ªü ‚ÄúDanh s√°ch b·∫°n b√®‚Äù b√™n d∆∞·ªõi ‚Üí thanh ‚ÄúT·∫°o nh√≥m‚Äù s·∫Ω hi·ªán.
          </p>
        </div>

        <div class="glass-card">
          <div class="card-head">üí¨ Nh√≥m c·ªßa b·∫°n</div>
          <div id="groupList"></div>
          <div id="groupEmpty" class="login-sub" style="text-align:center;">Ch∆∞a c√≥ nh√≥m n√†o.</div>
        </div>

        <div class="glass-card">
          <div class="card-head">üì© L·ªùi m·ªùi ƒëang ch·ªù</div>
          <div id="incomingList"></div>
          <div id="incomingEmpty" class="login-sub" style="text-align:center;">Kh√¥ng c√≥ l·ªùi m·ªùi n√†o.</div>
        </div>

        <div class="glass-card">
          <div class="card-head">
            üë• Danh s√°ch b·∫°n b√®
            <span style="font-size:11px;color:#64748b;font-weight:700;">(tick ƒë·ªÉ t·∫°o nh√≥m)</span>
          </div>
          <div id="friendsList"></div>
          <div id="friendsEmpty" class="login-sub" style="text-align:center;">Ch∆∞a c√≥ ai h·∫øt.</div>
        </div>
      </div>

      <div id="viewProfile" class="view-container hidden">
        <div class="glass-card profile-header">
          <img id="userPhoto" class="profile-avatar" src="" alt="">
          <div id="userName" class="profile-name">...</div>
          <div id="userEmail" class="profile-email">...</div>
        </div>

        <div class="glass-card">
          <div class="card-head">
            <span>üì° Chia s·∫ª v·ªã tr√≠</span>
            <button id="btnToggleShare" class="btn success" style="padding:6px 12px;font-size:12px;">B·∫≠t</button>
          </div>
          <p id="shareDesc" class="login-sub">Khi b·∫≠t, b·∫°n b√® s·∫Ω th·∫•y icon c·ªßa b·∫°n di chuy·ªÉn tr√™n b·∫£n ƒë·ªì.</p>
        </div>

        <div class="glass-card">
          <div class="card-head">
            <span>üîî Th√¥ng b√°o tin nh·∫Øn</span>
            <button id="btnToggleNoti" class="btn secondary" style="padding:6px 12px;font-size:12px;">B·∫≠t</button>
          </div>
          <p id="notiDesc" class="login-sub">C·∫•p quy·ªÅn ƒë·ªÉ nh·∫≠n th√¥ng b√°o khi c√≥ tin nh·∫Øn m·ªõi.</p>
        </div>

        <button id="btnLogout" class="btn danger" style="width:100%;justify-content:center;">ƒêƒÉng xu·∫•t</button>

        <div style="text-align:center;margin-top:30px;font-size:11px;color:var(--text-muted);">
          Friends Map v3.5 - Inbox Badge + Notifications
        </div>
      </div>
    </div>

    <div id="groupActionBar" class="group-actionbar hidden">
      <div class="gab-left"><b id="gabCount">0</b> ƒë√£ ch·ªçn</div>
      <button id="btnOpenGroupModal" class="btn primary" style="padding:10px 12px;border-radius:14px;">
        üë®‚Äçüë©‚Äçüëß‚Äçüë¶ T·∫°o nh√≥m
      </button>
    </div>

    <nav class="bottom-nav">
      <div class="nav-item active" id="tabMap">
        <div class="nav-icon">üó∫Ô∏è</div><span>B·∫£n ƒë·ªì</span>
      </div>
      <div class="nav-item" id="tabFriends">
        <div class="nav-icon">üë•</div><span>B·∫°n b√®</span>
      </div>
      <div class="nav-item" id="tabProfile">
        <div class="nav-icon">‚öôÔ∏è</div><span>C√†i ƒë·∫∑t</span>
      </div>
    </nav>
  </section>

  <!-- ‚úÖ Modal chat -->
  <div id="chatBackdrop" class="modal-backdrop">
    <div class="chat-modal">
      <div class="chat-head">
        <div class="chat-head-left">
          <img id="chatAva" class="chat-ava" src="" alt="">
          <div style="min-width:0">
            <div style="display:flex; align-items:center;">
              <div id="chatTitle" class="chat-title">Chat</div>
              <span id="chatChip" class="chip hidden">GROUP</span>
            </div>
            <div id="chatSub" class="chat-sub">...</div>
          </div>
        </div>
        <div style="display:flex;gap:8px;">
          <button id="btnChatRoute" class="btn secondary" style="padding:8px 10px;font-size:12px;">üß≠ Ch·ªâ ƒë∆∞·ªùng</button>
          <button id="btnChatClose" class="btn secondary" style="padding:8px 10px;font-size:12px;">‚úñ</button>
        </div>
      </div>

      <div id="chatBody" class="chat-body"></div>
      <div id="seenLine" class="seen-line"></div>

      <div class="chat-foot">
        <input id="chatInput" class="chat-input" placeholder="Nh·∫Øn tin..." />
        <button id="btnChatSend" class="btn primary" style="padding:10px 12px;">G·ª≠i</button>
      </div>
    </div>
  </div>

  <!-- ‚úÖ Modal t·∫°o nh√≥m t·ª´ tick -->
  <div id="groupBackdrop" class="modal-backdrop">
    <div class="chat-modal" style="height:auto;max-height:78vh;">
      <div class="chat-head">
        <div class="chat-head-left">
          <img class="chat-ava" src="https://www.gravatar.com/avatar/?d=identicon&s=96" alt="">
          <div style="min-width:0">
            <div class="chat-title">T·∫°o nh√≥m chat</div>
            <div class="chat-sub">Ch·ªçn b·∫°n ·ªü danh s√°ch r·ªìi ƒë·∫∑t t√™n nh√≥m</div>
          </div>
        </div>
        <button id="btnCloseGroupModal" class="btn secondary" style="padding:8px 10px;font-size:12px;">‚úñ</button>
      </div>

      <div class="chat-body" style="padding:12px;">
        <input id="groupName2" class="inp" placeholder="T√™n nh√≥m..." style="margin-bottom:10px;">
        <div style="display:flex;gap:8px;margin-bottom:10px;">
          <button id="btnSelectAllFriends" class="btn secondary" style="padding:8px 10px;font-size:12px;">Ch·ªçn t·∫•t c·∫£</button>
          <button id="btnClearSelectFriends" class="btn secondary" style="padding:8px 10px;font-size:12px;">B·ªè ch·ªçn</button>
        </div>
        <div id="selectedPreview" class="login-sub" style="margin:0 0 10px;font-size:12px;"></div>
        <button id="btnCreateGroupFromSelected" class="btn primary" style="width:100%">‚úÖ T·∫°o nh√≥m</button>
      </div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
    import { getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js";
    import {
      getFirestore, doc, setDoc, getDoc, updateDoc, deleteDoc,
      collection, addDoc, query, where, onSnapshot, serverTimestamp
    } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";
    import {
      getDatabase, ref, push, set, update, onDisconnect, onValue, off,
      query as rQuery, limitToLast,
      serverTimestamp as rtdbServerTimestamp,
      runTransaction
    } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-database.js";

    // ===== Firebase Config =====
    const firebaseConfig = {
      apiKey: "AIzaSyD6KpR4WVafZuMt5Xz3gbxZ8pMEaBClJzE",
      authDomain: "app-map-35d16.firebaseapp.com",
      projectId: "app-map-35d16",
      storageBucket: "app-map-35d16.firebasestorage.app",
      messagingSenderId: "983110991757",
      appId: "1:983110991757:web:ebd820dfaa148f96c407c4",
      measurementId: "G-61CH1RKWDH"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    const rtdb = getDatabase(app);
    const provider = new GoogleAuthProvider();

    // ===== Utils =====
    const $ = (id) => document.getElementById(id);
    const toast = (msg) => {
      const t = $("toast");
      t.textContent = msg;
      t.classList.add("show");
      clearTimeout(window.__toastTimer);
      window.__toastTimer = setTimeout(()=>t.classList.remove("show"), 2500);
    };
    function safeAva(url){ return url || "https://www.gravatar.com/avatar/?d=mp&s=96"; }
    function friendDocId(a,b){ return (a<b)?`${a}_${b}`:`${b}_${a}`; }

    // ===== RTDB Paths =====
    const liveLocPath = (uid) => `liveLocations/${uid}`;
    const statusPath  = (uid) => `status/${uid}`;
    const inboxPath   = (uid) => `inbox/${uid}`; // ‚úÖ unread badge & last message info

    const inboxKeyDM = (dmId)=> `dm_${dmId}`;
    const inboxKeyGroup = (gid)=> `group_${gid}`;

    // ===== Tabs =====
    const views = { map: $("viewMap"), friends: $("viewFriends"), profile: $("viewProfile") };
    const tabs = { map: $("tabMap"), friends: $("tabFriends"), profile: $("tabProfile") };
    const topTitle = $("topTitle");

    function setTab(name){
      Object.values(views).forEach(el=>el.classList.add("hidden"));
      Object.values(tabs).forEach(el=>el.classList.remove("active"));

      views[name].classList.remove("hidden");
      tabs[name].classList.add("active");

      if(name==="map") topTitle.textContent="B·∫£n ƒë·ªì";
      if(name==="friends") topTitle.textContent="B·∫°n b√®";
      if(name==="profile") topTitle.textContent="C√° nh√¢n";

      if(name==="map" && window.__leafletMap){
        setTimeout(()=>window.__leafletMap.invalidateSize(), 200);
      }
    }
    tabs.map.onclick=()=>setTab("map");
    tabs.friends.onclick=()=>setTab("friends");
    tabs.profile.onclick=()=>setTab("profile");
    $("btnGoProfile").onclick=()=>setTab("profile");

    // ===== Map (ch·ªâ OSM) =====
    const map = L.map("map", { zoomControl:false }).setView([21.0278,105.8342], 13);
    window.__leafletMap = map;

    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19, attribution: "¬© OpenStreetMap"
    }).addTo(map);

    let me = null;
    let myMarker = null;
    const friendMarkers = new Map();
    const friendLocs = new Map();
    const userCache = new Map();
    const friendPresence = new Map(); // uid -> {state,lastChanged}
    const friendRowRefs = new Map();  // uid -> {statusEl,badgeEl,chatBtnWrap}
    const groupRowRefs  = new Map();  // gid -> {badgeEl}

    let routeLayer = null;
    let routingToUid = null;

    function makeAvatarIcon(photoURL, isMe, isSharing=true){
      const ring = isSharing ? (isMe ? "ring-me" : "ring-friend") : "ring-off";
      return L.divIcon({
        className:"avatar-marker",
        html:`<div class="avatar-wrap ${ring}"><img src="${safeAva(photoURL)}" alt=""></div>`,
        iconSize:[44,44],
        iconAnchor:[22,44],
        popupAnchor:[0,-40]
      });
    }

    function upsertMyMarker(lat,lng){
      const pos=[lat,lng];
      const icon = makeAvatarIcon(me?.photoURL, true, true);
      if(!myMarker){
        myMarker = L.marker(pos,{icon}).addTo(map).bindPopup("<b>üìç B·∫°n ƒëang ·ªü ƒë√¢y</b>");
      }else{
        myMarker.setLatLng(pos);
        myMarker.setIcon(icon);
      }
    }

    function friendPopupHtml(fid){
      const u = userCache.get(fid) || {};
      const pr = friendPresence.get(fid);
      const isOn = pr?.state === "online";
      const sub1 = u.email || ("UID: " + fid.slice(0,6) + "...");
      const sub2 = isOn ? "üü¢ Online" : "‚ö™ Offline";
      return `
        <div>
          <div class="pop">
            <img src="${safeAva(u.photoURL)}" />
            <div>
              <b>${u.displayName || "B·∫°n b√®"}</b>
              <small>${sub1}</small>
              <small>${sub2}</small>
            </div>
          </div>
          <div class="pop-actions">
            <button class="btn primary" data-action="chat" data-uid="${fid}">üí¨ Chat</button>
            <button class="btn secondary" data-action="route" data-uid="${fid}">üß≠ Ch·ªâ ƒë∆∞·ªùng</button>
          </div>
        </div>
      `;
    }

    function upsertFriendMarker(uid,lat,lng,isSharing){
      const pos=[lat,lng];
      const u = userCache.get(uid) || {};
      const icon = makeAvatarIcon(u.photoURL, false, !!isSharing);

      const existing = friendMarkers.get(uid);
      if(!existing){
        const m = L.marker(pos,{icon}).addTo(map).bindPopup(friendPopupHtml(uid));
        friendMarkers.set(uid,m);
      }else{
        existing.setLatLng(pos);
        existing.setIcon(icon);
        existing.setPopupContent(friendPopupHtml(uid));
      }
    }

    function removeFriendMarker(uid){
      const m = friendMarkers.get(uid);
      if(m){ map.removeLayer(m); friendMarkers.delete(uid); }
    }

    map.on("popupopen", (e)=>{
      const root = e.popup.getElement();
      if(!root) return;
      root.querySelectorAll("button[data-action]").forEach(btn=>{
        btn.onclick=()=>{
          const uid = btn.getAttribute("data-uid");
          const action = btn.getAttribute("data-action");
          if(!uid) return;
          if(action==="chat") openDM(uid);
          if(action==="route") startRoutingTo(uid);
        };
      });
    });

    // ===== Geo =====
    let watchId=null;
    let lastPos=null;

    function requestLocation(manual=false){
      if(!navigator.geolocation) return toast("M√°y kh√¥ng c√≥ GPS");
      if(manual) toast("ƒêang d√≤ v·ªã tr√≠...");
      navigator.geolocation.getCurrentPosition(
        (pos)=>{
          updateMyPos(pos);
          if(manual){
            map.setView([pos.coords.latitude,pos.coords.longitude],16);
            toast("ƒê√£ c·∫≠p nh·∫≠t v·ªã tr√≠!");
          }
        },
        (err)=>{ if(manual) toast("Kh√¥ng d√≤ ƒë∆∞·ª£c: " + err.message); },
        { enableHighAccuracy:true, timeout:10000, maximumAge:0 }
      );
    }

    async function pushLiveLocation(force=false){
      if(!me || !sharing || !lastPos) return;
      const now = Date.now();
      if(!force && now - (window.__lastPushTs||0) < 2000) return;
      window.__lastPushTs = now;

      try{
        await set(ref(rtdb, liveLocPath(me.uid)), {
          sharing: true,
          lat: lastPos.lat,
          lng: lastPos.lng,
          updatedAt: now,
          name: me.displayName || "",
          photoURL: me.photoURL || ""
        });
      }catch(e){ console.error("pushLiveLocation error:", e); }
    }

    async function pushShareOff(){
      if(!me) return;
      try{
        await set(ref(rtdb, liveLocPath(me.uid)), {
          sharing: false,
          updatedAt: Date.now(),
          name: me.displayName || "",
          photoURL: me.photoURL || ""
        });
      }catch(e){ console.error("pushShareOff error:", e); }
    }

    function updateMyPos(pos){
      lastPos = { lat:pos.coords.latitude, lng:pos.coords.longitude, ts:Date.now() };
      upsertMyMarker(lastPos.lat,lastPos.lng);
      pushLiveLocation(false);
      if(routingToUid) drawRouteTo(routingToUid, false);
    }

    function startGeolocationWatch(){
      if(!navigator.geolocation) return;
      requestLocation(false);

      if(watchId!=null) navigator.geolocation.clearWatch(watchId);
      watchId = navigator.geolocation.watchPosition(
        (pos)=>{
          updateMyPos(pos);
          if(!window.__centered){
            map.setView([pos.coords.latitude,pos.coords.longitude],15);
            window.__centered=true;
          }
        },
        ()=>{},
        { enableHighAccuracy:true, maximumAge:10000 }
      );
    }

    function stopGeolocationWatch(){
      if(watchId!=null){ navigator.geolocation.clearWatch(watchId); watchId=null; }
    }

    $("btnLocateMe").onclick=()=>requestLocation(true);

    // ===== Routing (OSRM) =====
    function clearRoute(){
      routingToUid=null;
      if(routeLayer){ map.removeLayer(routeLayer); routeLayer=null; }
      toast("ƒê√£ x√≥a ƒë∆∞·ªùng ƒëi");
    }
    $("btnClearRoute").onclick=()=>clearRoute();

    async function startRoutingTo(fid){
      routingToUid = fid;
      setTab("map");
      await drawRouteTo(fid, true);
    }

    async function drawRouteTo(fid, fit=false){
      try{
        if(!lastPos) return toast("Ch∆∞a c√≥ v·ªã tr√≠ c·ªßa b·∫°n");
        const f = friendLocs.get(fid);
        if(!f) return toast("Ch∆∞a c√≥ d·ªØ li·ªáu v·ªã tr√≠ b·∫°n b√®");
        if(!f.sharing) return toast("B·∫°n b√® ƒëang ·∫©n v·ªã tr√≠");
        if(typeof f.lat !== "number" || typeof f.lng !== "number") return toast("B·∫°n b√® ch∆∞a g·ª≠i v·ªã tr√≠");

        const url = `https://router.project-osrm.org/route/v1/driving/${lastPos.lng},${lastPos.lat};${f.lng},${f.lat}?overview=full&geometries=geojson`;
        const res = await fetch(url);
        const data = await res.json();
        if(!data.routes || !data.routes[0]) return toast("Kh√¥ng l·∫•y ƒë∆∞·ª£c ƒë∆∞·ªùng ƒëi");

        const coords = data.routes[0].geometry.coordinates.map(c=>[c[1],c[0]]);
        if(routeLayer) map.removeLayer(routeLayer);
        routeLayer = L.polyline(coords).addTo(map);

        if(fit){
          map.fitBounds(routeLayer.getBounds(), { padding:[40,40] });
        }

        const km = ((data.routes[0].distance||0)/1000).toFixed(1);
        const mins = Math.round((data.routes[0].duration||0)/60);
        toast(`üß≠ ${km} km ‚Ä¢ ~${mins} ph√∫t`);
      }catch(e){
        toast("L·ªói ch·ªâ ƒë∆∞·ªùng: " + (e.message||"unknown"));
      }
    }

    // ===== Firestore Helpers =====
    async function ensureUserDoc(user){
      await setDoc(doc(db,"users",user.uid),{
        displayName:user.displayName||"No name",
        email:user.email||"",
        photoURL:user.photoURL||"",
        lastSeen:serverTimestamp()
      },{merge:true});
    }
    async function ensurePublicEmailIndex(user){
      if(!user.email) return;
      const key = user.email.trim().toLowerCase().replaceAll(".","(dot)");
      await setDoc(doc(db,"publicEmail",key),{uid:user.uid},{merge:true});
    }
    async function findUidByEmail(email){
      const key = email.trim().toLowerCase().replaceAll(".","(dot)");
      const snap = await getDoc(doc(db,"publicEmail",key));
      return snap.exists()?snap.data().uid:null;
    }
    async function getUserInfo(uid){
      if(userCache.has(uid)) return userCache.get(uid);
      const s = await getDoc(doc(db,"users",uid));
      const data = s.exists()?s.data():{displayName:"B·∫°n b√®",email:"",photoURL:""};
      userCache.set(uid,data);
      return data;
    }

    // ===== Presence (RTDB) =====
    async function startPresence(){
      if(!me) return;
      const stRef = ref(rtdb, statusPath(me.uid));

      await onDisconnect(stRef).set({
        state: "offline",
        lastChanged: Date.now()
      });

      await set(stRef, {
        state: "online",
        lastChanged: Date.now(),
        name: me.displayName || "",
        photoURL: me.photoURL || ""
      });
    }

    // ===== Lifecycle flush =====
    function bindLifecycleHooks(){
      const flush = async ()=>{
        try{
          if(me && sharing && lastPos) await pushLiveLocation(true);
        }catch{}
      };
      window.addEventListener("pagehide", flush, { capture:true });
      document.addEventListener("visibilitychange", ()=>{
        if(document.visibilityState === "hidden") flush();
      });
    }

    // ===== Sharing =====
    let sharing=false;

    async function setSharingUI(on){
      sharing=!!on;
      const btn=$("btnToggleShare");
      const label=$("shareDesc");

      if(sharing){
        btn.textContent="T·∫Øt"; btn.className="btn danger";
        label.textContent="üü¢ ƒêang chia s·∫ª.";
        if(lastPos) await pushLiveLocation(true);

        // ‚úÖ n·∫øu m·∫•t m·∫°ng/ƒë√≥ng app -> set sharing false
        const myLiveRef = ref(rtdb, liveLocPath(me.uid));
        await onDisconnect(myLiveRef).set({
          sharing:false,
          updatedAt: Date.now(),
          name: me.displayName || "",
          photoURL: me.photoURL || ""
        });

      }else{
        btn.textContent="B·∫≠t"; btn.className="btn success";
        label.textContent="‚ö™ ƒêang ·∫©n.";
        await pushShareOff();
      }

      // backup Firestore locations
      if (me) {
        const payload = { sharing, updatedAt: serverTimestamp() };
        if (sharing && lastPos) { payload.lat = lastPos.lat; payload.lng = lastPos.lng; }
        await setDoc(doc(db, "locations", me.uid), payload, { merge: true });
      }

      if(lastPos && me) upsertMyMarker(lastPos.lat,lastPos.lng);
    }

    // ===== Notification toggle =====
    function refreshNotiUI(){
      const btn = $("btnToggleNoti");
      const desc = $("notiDesc");
      const p = Notification?.permission;
      if(!Notification){
        btn.textContent="Kh√¥ng h·ªó tr·ª£"; btn.className="btn secondary";
        desc.textContent="Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ Notification.";
        return;
      }
      if(p === "granted"){
        btn.textContent="ƒê√£ b·∫≠t"; btn.className="btn success";
        desc.textContent="‚úÖ ƒê√£ c·∫•p quy·ªÅn. Khi c√≥ tin nh·∫Øn m·ªõi s·∫Ω hi·ªán th√¥ng b√°o (khi app ƒëang ch·∫°y/·∫©n tab).";
      }else if(p === "denied"){
        btn.textContent="B·ªã ch·∫∑n"; btn.className="btn danger";
        desc.textContent="‚ùå B·∫°n ƒë√£ ch·∫∑n. V√†o c√†i ƒë·∫∑t tr√¨nh duy·ªát ƒë·ªÉ b·∫≠t l·∫°i.";
      }else{
        btn.textContent="B·∫≠t"; btn.className="btn secondary";
        desc.textContent="C·∫•p quy·ªÅn ƒë·ªÉ nh·∫≠n th√¥ng b√°o khi c√≥ tin nh·∫Øn m·ªõi.";
      }
    }

    $("btnToggleNoti").onclick = async ()=>{
      if(!Notification) return toast("Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ Notification");
      if(Notification.permission === "granted") return toast("ƒê√£ b·∫≠t r·ªìi");
      const p = await Notification.requestPermission();
      refreshNotiUI();
      if(p === "granted") toast("‚úÖ ƒê√£ b·∫≠t th√¥ng b√°o!");
      else toast("B·∫°n ch∆∞a c·∫•p quy·ªÅn");
    };

    function maybeNotify(title, body, icon){
      try{
        if(!Notification) return;
        if(Notification.permission !== "granted") return;
        if(document.visibilityState === "visible") return; // ƒëang m·ªü app th√¨ th√¥i (ƒë·ª° spam)
        new Notification(title || "Tin nh·∫Øn m·ªõi", { body: body || "", icon: icon || safeAva("") });
      }catch{}
    }

    // ===== Friends + Locations =====
    $("btnSendRequest").onclick = async ()=>{
      const email=$("friendEmail").value.trim();
      if(!email) return toast("Ch∆∞a nh·∫≠p email!");
      try{
        const uid = await findUidByEmail(email);
        if(!uid) return toast("Ng∆∞·ªùi n√†y ch∆∞a d√πng app.");
        if(uid===me.uid) return toast("Kh√¥ng th·ªÉ t·ª± k·∫øt b·∫°n.");
        await addDoc(collection(db,"friendRequests"),{
          from:me.uid, to:uid, status:"pending", createdAt:serverTimestamp()
        });
        toast("ƒê√£ g·ª≠i l·ªùi m·ªùi!");
        $("friendEmail").value="";
      }catch(e){ toast("L·ªói: " + e.message); }
    };

    let unsubIncoming=null;
    let unsubFriends=null;
    const unsubLocs=new Map();
    const unsubStatus=new Map();

    function listenIncoming(){
      if(unsubIncoming) unsubIncoming();
      const qy = query(collection(db,"friendRequests"),
        where("to","==",me.uid),
        where("status","==","pending")
      );

      unsubIncoming = onSnapshot(qy,(snap)=>{
        const list=$("incomingList");
        list.innerHTML="";
        $("incomingEmpty").style.display = snap.empty ? "block":"none";

        snap.forEach(d=>{
          const r=d.data();
          const div=document.createElement("div");
          div.className="list-item";
          div.innerHTML=`
            <div class="list-left">
              <img class="list-ava" src="https://www.gravatar.com/avatar/?d=mp&s=96">
              <div class="list-info">
                <b>L·ªùi m·ªùi k·∫øt b·∫°n</b>
                <small>T·ª´ UID: ${r.from?.substr(0,6)}...</small>
              </div>
            </div>
            <div style="display:flex;gap:8px">
              <button class="btn success" style="padding:6px 10px">‚úî</button>
              <button class="btn danger" style="padding:6px 10px">‚úò</button>
            </div>
          `;

          div.querySelector(".btn.success").onclick = async ()=>{
            await updateDoc(doc(db,"friendRequests",d.id),{status:"accepted"});
            const fid = friendDocId(me.uid, r.from);
            await setDoc(doc(db, "friends", fid), {
              a: me.uid,
              b: r.from,
              users: { [me.uid]: true, [r.from]: true },
              createdAt: serverTimestamp()
            }, { merge: true });
            await attachFriendLocationListener(r.from);
            await attachFriendPresenceListener(r.from);
            toast("ƒê√£ ch·∫•p nh·∫≠n!");
          };

          div.querySelector(".btn.danger").onclick = async ()=>{
            await updateDoc(doc(db,"friendRequests",d.id),{status:"rejected"});
            toast("ƒê√£ t·ª´ ch·ªëi.");
          };

          list.appendChild(div);
        });
      });
    }

    async function attachFriendPresenceListener(fid){
      if(unsubStatus.has(fid)) return;

      const stRef = ref(rtdb, statusPath(fid));
      const handler = (snap)=>{
        if(!snap.exists()){
          friendPresence.delete(fid);
        }else{
          friendPresence.set(fid, snap.val() || {});
        }

        // ‚úÖ update UI row if exists
        const row = friendRowRefs.get(fid);
        if(row?.statusEl){
          const pr = friendPresence.get(fid);
          const isOn = pr?.state === "online";
          row.statusEl.textContent = isOn ? "üü¢ Online" : "‚ö™ Offline";
        }

        // refresh popup
        const mk = friendMarkers.get(fid);
        if(mk) mk.setPopupContent(friendPopupHtml(fid));
      };
      onValue(stRef, handler, (err)=>console.error("presence listener err:", err));
      unsubStatus.set(fid, ()=> off(stRef, "value", handler));
    }

    async function attachFriendLocationListener(fid){
      if(unsubLocs.has(fid)) return;
      await getUserInfo(fid);

      const locRef = ref(rtdb, liveLocPath(fid));
      const handler = (snap)=>{
        if(!snap.exists()){
          friendLocs.delete(fid);
          removeFriendMarker(fid);
          if(routingToUid===fid) clearRoute();
          return;
        }

        const l = snap.val() || {};
        friendLocs.set(fid,l);

        const u = userCache.get(fid) || {};
        if((l.name && !u.displayName) || (l.photoURL && !u.photoURL)){
          userCache.set(fid, {
            ...u,
            displayName: u.displayName || l.name || "B·∫°n b√®",
            photoURL: u.photoURL || l.photoURL || ""
          });
        }

        if(!l.sharing){
          removeFriendMarker(fid);
          if(routingToUid===fid) clearRoute();
          return;
        }

        if(typeof l.lat !== "number" || typeof l.lng !== "number"){
          removeFriendMarker(fid);
          return;
        }

        upsertFriendMarker(fid, l.lat, l.lng, true);

        if(routingToUid === fid){
          drawRouteTo(fid, false);
        }
      };

      onValue(locRef, handler, (err)=>{
        console.error("liveLocations listener error:", err);
        toast("Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c v·ªã tr√≠ b·∫°n b√®: " + (err?.message || err));
      });

      unsubLocs.set(fid, ()=> off(locRef, "value", handler));
    }

    function detachAllFriendLocListeners(){
      unsubLocs.forEach((unsub)=>{ try{unsub();}catch{} });
      unsubLocs.clear();

      unsubStatus.forEach((unsub)=>{ try{unsub();}catch{} });
      unsubStatus.clear();

      friendLocs.clear();
      friendPresence.clear();
      friendRowRefs.clear();
      groupRowRefs.clear();

      friendMarkers.forEach((m,uid)=>removeFriendMarker(uid));
      clearRoute();
    }

    // ===== Tick ch·ªçn b·∫°n -> t·∫°o nh√≥m =====
    const selectedFriends = new Set();
    const groupActionBar = $("groupActionBar");
    const gabCount = $("gabCount");
    const groupBackdrop = $("groupBackdrop");
    const selectedPreview = $("selectedPreview");

    function updateGroupBarUI(){
      const n = selectedFriends.size;
      gabCount.textContent = n;
      groupActionBar.classList.toggle("hidden", n === 0);
      selectedPreview.textContent = n ? `ƒêang ch·ªçn: ${n} ng∆∞·ªùi` : "Ch∆∞a ch·ªçn ai.";
    }

    function bindFriendCheckbox(div){
      const cb = div.querySelector(".friend-check");
      if(!cb) return;
      const uid = cb.getAttribute("data-uid");
      cb.checked = selectedFriends.has(uid);

      cb.onchange = ()=>{
        if(cb.checked) selectedFriends.add(uid);
        else selectedFriends.delete(uid);
        updateGroupBarUI();
      };
    }

    $("btnOpenGroupModal").onclick = ()=>{
      groupBackdrop.classList.add("show");
      updateGroupBarUI();
    };
    $("btnCloseGroupModal").onclick = ()=> groupBackdrop.classList.remove("show");
    groupBackdrop.onclick = (e)=>{ if(e.target===groupBackdrop) groupBackdrop.classList.remove("show"); };

    $("btnSelectAllFriends").onclick = ()=>{
      document.querySelectorAll(".friend-check").forEach(cb=>{
        cb.checked = true;
        selectedFriends.add(cb.getAttribute("data-uid"));
      });
      updateGroupBarUI();
    };
    $("btnClearSelectFriends").onclick = ()=>{
      document.querySelectorAll(".friend-check").forEach(cb=> cb.checked = false);
      selectedFriends.clear();
      updateGroupBarUI();
    };

    // ===== Groups (Firestore) =====
    let unsubGroups = null;
    const groupCache = new Map(); // gid -> {name, members}

    $("btnCreateGroupFromSelected").onclick = async ()=>{
      try{
        const name = $("groupName2").value.trim();
        if(!name) return toast("Ch∆∞a nh·∫≠p t√™n nh√≥m!");
        if(selectedFriends.size < 1) return toast("Ch∆∞a ch·ªçn b·∫°n n√†o!");

        const members = { [me.uid]: true };
        selectedFriends.forEach(uid => members[uid] = true);

        await addDoc(collection(db, "groups"),{
          name,
          owner: me.uid,
          members,
          createdAt: serverTimestamp()
        });

        toast("‚úÖ ƒê√£ t·∫°o nh√≥m!");
        $("groupName2").value="";
        selectedFriends.clear();
        updateGroupBarUI();
        groupBackdrop.classList.remove("show");
      }catch(e){
        toast("L·ªói t·∫°o nh√≥m: " + (e.message || e));
      }
    };

    function setBadge(badgeEl, n){
      if(!badgeEl) return;
      const v = Number(n||0);
      if(v <= 0){
        badgeEl.classList.add("hidden");
        badgeEl.textContent = "";
      }else{
        badgeEl.classList.remove("hidden");
        badgeEl.textContent = v > 99 ? "99+" : String(v);
      }
    }

    // ===== Inbox listener (badge + notify) =====
    let unsubInbox = null;
    const inboxState = new Map(); // key -> entry
    const prevInboxUnread = new Map(); // key -> unread

    function listenInbox(){
      if(unsubInbox) { try{unsubInbox();}catch{} }
      inboxState.clear();
      prevInboxUnread.clear();

      const inRef = ref(rtdb, inboxPath(me.uid));
      const handler = (snap)=>{
        const data = snap.val() || {};
        // rebuild map
        for(const k of Object.keys(data)){
          const entry = data[k] || {};
          inboxState.set(k, entry);

          const oldUnread = prevInboxUnread.get(k) || 0;
          const newUnread = Number(entry.unread||0);

          // update friend badges
          if(entry.type === "dm" && entry.peerUid){
            const row = friendRowRefs.get(entry.peerUid);
            if(row?.badgeEl) setBadge(row.badgeEl, newUnread);
          }
          // update group badges
          if(entry.type === "group" && entry.groupId){
            const row = groupRowRefs.get(entry.groupId);
            if(row?.badgeEl) setBadge(row.badgeEl, newUnread);
          }

          // notify if new unread increased (from others)
          if(newUnread > oldUnread && entry.lastFrom && entry.lastFrom !== me.uid){
            const title = entry.title || "Tin nh·∫Øn m·ªõi";
            const body  = entry.lastText || "";
            const icon  = entry.photoURL || safeAva("");
            maybeNotify(title, body, icon);
          }

          prevInboxUnread.set(k, newUnread);
        }

        // also clear badges for removed keys
        for(const k of Array.from(prevInboxUnread.keys())){
          if(!(k in data)){
            prevInboxUnread.delete(k);
          }
        }
      };
      onValue(inRef, handler, (err)=>console.error("inbox listener error:", err));
      unsubInbox = ()=> off(inRef, "value", handler);
    }

    async function clearInboxUnreadForDM(peerUid){
      const dmId = friendDocId(me.uid, peerUid);
      const key = inboxKeyDM(dmId);
      try{
        await update(ref(rtdb, `${inboxPath(me.uid)}/${key}`), { unread: 0, readAt: Date.now() });
      }catch{}
    }
    async function clearInboxUnreadForGroup(groupId){
      const key = inboxKeyGroup(groupId);
      try{
        await update(ref(rtdb, `${inboxPath(me.uid)}/${key}`), { unread: 0, readAt: Date.now() });
      }catch{}
    }

    // ===== Friends list =====
    function listenFriends() {
      if (unsubFriends) unsubFriends();
      const qy = query(collection(db, "friends"), where(`users.${me.uid}`, "==", true));

      unsubFriends = onSnapshot(
        qy,
        async (snap) => {
          const friends = [];
          snap.forEach(d => {
            const data = d.data() || {};
            const uids = Object.keys(data.users || {});
            const fid = uids.find(x => x !== me.uid);
            if (fid) friends.push(fid);
          });

          const list = $("friendsList");
          list.innerHTML = "";
          $("friendsEmpty").style.display = friends.length ? "none" : "block";

          const current = new Set(friends);
          Array.from(unsubLocs.keys()).forEach(fid => {
            if (!current.has(fid)) {
              try { unsubLocs.get(fid)(); } catch {}
              unsubLocs.delete(fid);

              try { unsubStatus.get(fid)(); } catch {}
              unsubStatus.delete(fid);

              friendLocs.delete(fid);
              friendPresence.delete(fid);
              friendRowRefs.delete(fid);
              removeFriendMarker(fid);
              if (routingToUid === fid) clearRoute();

              selectedFriends.delete(fid);
              updateGroupBarUI();
            }
          });

          for (const fid of friends) {
            const u = await getUserInfo(fid);

            const div = document.createElement("div");
            div.className = "list-item";

            // chat button + badge
            const dmId = friendDocId(me.uid, fid);
            const key = inboxKeyDM(dmId);
            const unread = Number(inboxState.get(key)?.unread || 0);

            div.innerHTML = `
              <div class="list-left">
                <input class="friend-check" type="checkbox" data-uid="${fid}">
                <img class="list-ava" src="${safeAva(u.photoURL)}" alt="">
                <div class="list-info" style="cursor:pointer;">
                  <b>${u.displayName || "B·∫°n b√®"}</b>
                  <small>${u.email || ("UID: " + fid.slice(0,8) + "...")}</small>
                  <small class="st">‚ö™ Offline</small>
                </div>
              </div>
              <div style="display:flex; gap:8px; flex: 0 0 auto; align-items:center;">
                <span class="icon-btnwrap">
                  <button class="btn secondary" style="padding:6px 10px; font-size:12px">üí¨</button>
                  <span class="badge ${unread>0?'':'hidden'}">${unread>0? (unread>99?'99+':unread):''}</span>
                </span>
                <button class="btn secondary" style="padding:6px 10px; font-size:12px">üß≠</button>
                <button class="btn danger" style="padding:6px 10px; font-size:12px">X√≥a</button>
              </div>
            `;

            bindFriendCheckbox(div);

            const statusEl = div.querySelector(".st");
            const badgeEl  = div.querySelector(".badge");
            friendRowRefs.set(fid, { statusEl, badgeEl });

            // set initial presence if already have
            const pr = friendPresence.get(fid);
            const isOn = pr?.state === "online";
            statusEl.textContent = isOn ? "üü¢ Online" : "‚ö™ Offline";

            const btnChat = div.querySelectorAll("button")[0];
            const btnRoute = div.querySelectorAll("button")[1];
            const btnDel  = div.querySelectorAll("button")[2];

            div.querySelector(".list-info").onclick = () => openDM(fid);
            btnChat.onclick = () => openDM(fid);
            btnRoute.onclick = () => startRoutingTo(fid);
            btnDel.onclick = async () => {
              if(!confirm("X√≥a b·∫°n n√†y?")) return;
              await deleteDoc(doc(db, "friends", friendDocId(me.uid, fid)));
              removeFriendMarker(fid);
              selectedFriends.delete(fid);
              updateGroupBarUI();
              toast("ƒê√£ x√≥a b·∫°n");
            };

            list.appendChild(div);

            await attachFriendLocationListener(fid);
            await attachFriendPresenceListener(fid);
          }
        },
        (err) => {
          console.error("listenFriends error:", err);
          toast("L·ªói friends: " + (err?.message || err));
        }
      );
    }

    // ===== Groups list =====
    function listenGroups(){
      if(unsubGroups) unsubGroups();
      groupCache.clear();

      const qy = query(collection(db,"groups"), where(`members.${me.uid}`, "==", true));
      unsubGroups = onSnapshot(qy, (snap)=>{
        const list = $("groupList");
        list.innerHTML="";
        $("groupEmpty").style.display = snap.empty ? "block" : "none";

        groupRowRefs.clear();

        snap.forEach(d=>{
          const g = d.data() || {};
          const gid = d.id;
          groupCache.set(gid, { name: g.name || "Nh√≥m chat", members: g.members || {} });

          const key = inboxKeyGroup(gid);
          const unread = Number(inboxState.get(key)?.unread || 0);

          const div = document.createElement("div");
          div.className = "list-item";
          div.innerHTML = `
            <div class="list-left" style="cursor:pointer;">
              <img class="list-ava" src="https://www.gravatar.com/avatar/?d=identicon&s=96" alt="">
              <div class="list-info">
                <b>üë®‚Äçüë©‚Äçüëß‚Äçüë¶ ${g.name || "Nh√≥m chat"}</b>
                <small>ID: ${gid.slice(0,8)}...</small>
              </div>
            </div>
            <div style="display:flex; gap:8px; flex:0 0 auto; align-items:center;">
              <span class="icon-btnwrap">
                <button class="btn secondary" style="padding:6px 10px; font-size:12px">üí¨</button>
                <span class="badge ${unread>0?'':'hidden'}">${unread>0? (unread>99?'99+':unread):''}</span>
              </span>
            </div>
          `;
          const btnChat = div.querySelector("button");
          const badgeEl = div.querySelector(".badge");
          groupRowRefs.set(gid, { badgeEl });

          div.querySelector(".list-left").onclick = ()=> openGroup(gid, g.name || "Nh√≥m chat");
          btnChat.onclick = ()=> openGroup(gid, g.name || "Nh√≥m chat");
          list.appendChild(div);
        });
      });
    }

    // ===== Chat (RTDB) =====
    let currentChatType = null;        // "dm" | "group"
    let currentChatId = null;          // dmId ho·∫∑c groupId
    let currentMsgsRef = null;

    let currentAddedHandler = null;
    let currentChangedHandler = null;

    let currentPeerUid = null;         // dm only
    let lastOutgoingKey = null;

    const chatBackdrop=$("chatBackdrop");
    const chatBody=$("chatBody");
    const chatInput=$("chatInput");
    const seenLine = $("seenLine");
    const chatChip = $("chatChip");

    function fmtTime(ts){
      try{
        const d=new Date(ts);
        return new Intl.DateTimeFormat("vi-VN",{hour:"2-digit",minute:"2-digit"}).format(d);
      }catch{return "";}
    }

    function chatPath(){
      if(currentChatType==="dm") return `chats/${currentChatId}/messages`;
      if(currentChatType==="group") return `groupChats/${currentChatId}/messages`;
      return null;
    }
    function chatMetaPath(){
      if(currentChatType==="dm") return `chats/${currentChatId}/meta`;
      if(currentChatType==="group") return `groupChats/${currentChatId}/meta`;
      return null;
    }
    function chatInboxKey(){
      if(currentChatType==="dm") return inboxKeyDM(currentChatId);
      if(currentChatType==="group") return inboxKeyGroup(currentChatId);
      return null;
    }

    function appendMessage(m){
      const isMe = m.from === me.uid;
      const row = document.createElement("div");
      row.className = "msg-row " + (isMe ? "me" : "other");

      const wrap = document.createElement("div");
      wrap.className = "msg-wrap";

      const bubble = document.createElement("div");
      bubble.className = "bubble";
      bubble.textContent = (m.text || "");

      const time = document.createElement("div");
      time.className = "msg-time";
      time.textContent = (typeof m.ts==="number") ? fmtTime(m.ts) : "";

      wrap.appendChild(bubble);
      wrap.appendChild(time);
      row.appendChild(wrap);
      chatBody.appendChild(row);
      chatBody.scrollTop = chatBody.scrollHeight;
    }

    function setSeenTextForMessage(msg, key){
      if(key !== lastOutgoingKey) return;

      if(currentChatType==="dm"){
        const ok = !!(msg?.readBy && currentPeerUid && msg.readBy[currentPeerUid]);
        seenLine.textContent = ok ? "‚úÖ ƒê√£ xem" : "";
        return;
      }

      if(currentChatType==="group"){
        const rb = msg?.readBy ? Object.keys(msg.readBy) : [];
        const others = rb.filter(uid => uid !== me.uid);
        seenLine.textContent = others.length ? `üëÄ ƒê√£ xem b·ªüi ${others.length} ng∆∞·ªùi` : "";
        return;
      }
    }

    async function markRead(snapKey){
      try{
        const p = chatPath();
        if(!p) return;

        // mark read in message
        await update(ref(rtdb, `${p}/${snapKey}`),{
          [`readBy/${me.uid}`]: true,
          [`readAt/${me.uid}`]: Date.now()
        });

        // clear unread in inbox for this chat
        const k = chatInboxKey();
        if(k){
          await update(ref(rtdb, `${inboxPath(me.uid)}/${k}`), { unread: 0, readAt: Date.now() });
        }
      }catch(e){
        console.error("markRead error:", e);
      }
    }

    function attachChatListeners(){
      const p = chatPath();
      if(!p) return;

      if(currentMsgsRef && currentAddedHandler) off(currentMsgsRef, "child_added", currentAddedHandler);
      if(currentMsgsRef && currentChangedHandler) off(currentMsgsRef, "child_changed", currentChangedHandler);

      currentMsgsRef = rQuery(ref(rtdb, p), limitToLast(160));

      currentAddedHandler = async (snap)=>{
        const m = snap.val();
        if(!m) return;

        appendMessage(m);

        if(m.from === me.uid){
          lastOutgoingKey = snap.key;
          setSeenTextForMessage(m, snap.key);
        }else{
          await markRead(snap.key);
        }
      };

      currentChangedHandler = (snap)=>{
        const m = snap.val();
        if(!m) return;
        if(m.from === me.uid){
          setSeenTextForMessage(m, snap.key);
        }
      };

      onValue(currentMsgsRef, ()=>{}, ()=>{}); // gi·ªØ ref "s·ªëng"
      // child events:
      import("https://www.gstatic.com/firebasejs/10.12.5/firebase-database.js").then(mod=>{
        mod.onChildAdded(currentMsgsRef, currentAddedHandler);
        mod.onChildChanged(currentMsgsRef, currentChangedHandler);
      });
    }

    function openChatUI({title, sub, ava, typeChip, showRouteBtn}){
      $("chatAva").src = ava || safeAva("");
      $("chatTitle").textContent = title || "Chat";
      $("chatSub").textContent = sub || "";
      chatBody.innerHTML = "";
      chatInput.value = "";
      seenLine.textContent = "";
      chatBackdrop.classList.add("show");

      if(typeChip){
        chatChip.textContent = typeChip;
        chatChip.classList.remove("hidden");
      }else{
        chatChip.classList.add("hidden");
      }

      $("btnChatRoute").style.display = showRouteBtn ? "inline-flex" : "none";
    }

    async function openDM(uid){
      if(!me) return;

      currentChatType = "dm";
      currentPeerUid = uid;
      currentChatId = friendDocId(me.uid, uid);
      lastOutgoingKey = null;

      const u = userCache.get(uid) || {};
      openChatUI({
        title: u.displayName || "B·∫°n b√®",
        sub: u.email || ("UID: " + uid.slice(0,8) + "..."),
        ava: safeAva(u.photoURL),
        typeChip: null,
        showRouteBtn: true
      });

      $("btnChatRoute").onclick = ()=> startRoutingTo(uid);

      // ‚úÖ clear badge
      await clearInboxUnreadForDM(uid);

      attachChatListeners();
    }

    async function openGroup(groupId, groupName){
      if(!me) return;

      currentChatType = "group";
      currentPeerUid = null;
      currentChatId = groupId;
      lastOutgoingKey = null;

      openChatUI({
        title: groupName || "Nh√≥m chat",
        sub: "Chat nh√≥m",
        ava: "https://www.gravatar.com/avatar/?d=identicon&s=96",
        typeChip: "GROUP",
        showRouteBtn: false
      });

      // ‚úÖ clear badge
      await clearInboxUnreadForGroup(groupId);

      attachChatListeners();
    }

    function closeChat(){
      chatBackdrop.classList.remove("show");

      // detach
      try{
        if(currentMsgsRef && currentAddedHandler){
          import("https://www.gstatic.com/firebasejs/10.12.5/firebase-database.js").then(mod=>{
            mod.off(currentMsgsRef, "child_added", currentAddedHandler);
          });
        }
        if(currentMsgsRef && currentChangedHandler){
          import("https://www.gstatic.com/firebasejs/10.12.5/firebase-database.js").then(mod=>{
            mod.off(currentMsgsRef, "child_changed", currentChangedHandler);
          });
        }
      }catch{}

      currentChatType = null;
      currentChatId = null;
      currentPeerUid = null;

      currentMsgsRef = null;
      currentAddedHandler = null;
      currentChangedHandler = null;

      lastOutgoingKey = null;
      seenLine.textContent = "";
    }

    $("btnChatClose").onclick = closeChat;
    chatBackdrop.onclick = (e)=>{ if(e.target===chatBackdrop) closeChat(); };

    // ===== Inbox update helpers (badge + last message) =====
    async function upsertInboxForMe(key, payload){
      // update sender inbox (unread 0)
      await update(ref(rtdb, `${inboxPath(me.uid)}/${key}`), {
        ...payload,
        unread: 0,
        readAt: Date.now(),
        updatedAt: Date.now()
      });
    }

    async function incInboxForUser(uid, key, payload){
      const baseRef = ref(rtdb, `${inboxPath(uid)}/${key}`);
      // merge payload + unread++
      await update(baseRef, { ...payload, updatedAt: Date.now() });
      await runTransaction(ref(rtdb, `${inboxPath(uid)}/${key}/unread`), (cur)=>{
        const v = Number(cur||0);
        return v + 1;
      });
    }

    async function sendMessage(){
      const text = chatInput.value.trim();
      if(!text) return;
      if(!me || !currentChatType || !currentChatId) return;

      chatInput.value = "";

      const p = chatPath();
      const metaP = chatMetaPath();
      if(!p || !metaP) return;

      const now = Date.now();

      try{
        const msgRef = push(ref(rtdb, p));
        const payload = {
          from: me.uid,
          text,
          ts: now,
          serverTs: rtdbServerTimestamp(),
          name: me.displayName || "",
          photoURL: me.photoURL || "",
          readBy: { [me.uid]: true },
          readAt: { [me.uid]: now }
        };
        await set(msgRef, payload);

        // update meta (optional)
        await update(ref(rtdb, metaP), {
          lastText: text,
          lastFrom: me.uid,
          lastFromName: me.displayName || "",
          lastTs: now
        });

        lastOutgoingKey = msgRef.key;
        seenLine.textContent = "";

        // ‚úÖ update inbox (badge) like messenger
        if(currentChatType === "dm"){
          const peerUid = currentPeerUid;
          const dmId = currentChatId;
          const key = inboxKeyDM(dmId);

          const u = userCache.get(peerUid) || {};
          const myTitleForPeer = me.displayName || "B·∫°n b√®";
          const myPhoto = me.photoURL || "";

          const peerTitleForMe = u.displayName || "B·∫°n b√®";
          const peerPhotoForMe = u.photoURL || "";

          // sender inbox (me)
          await upsertInboxForMe(key, {
            type:"dm",
            chatId: dmId,
            peerUid,
            title: peerTitleForMe,
            photoURL: peerPhotoForMe,
            lastText: text,
            lastFrom: me.uid,
            lastFromName: me.displayName || "",
            lastTs: now
          });

          // receiver inbox (peer) => unread++
          await incInboxForUser(peerUid, key, {
            type:"dm",
            chatId: dmId,
            peerUid: me.uid,
            title: myTitleForPeer,
            photoURL: myPhoto,
            lastText: text,
            lastFrom: me.uid,
            lastFromName: me.displayName || "",
            lastTs: now
          });

        }else if(currentChatType === "group"){
          const gid = currentChatId;
          const key = inboxKeyGroup(gid);
          const g = groupCache.get(gid) || { name:"Nh√≥m chat", members:{} };
          const members = Object.keys(g.members || {});
          const groupTitle = g.name || "Nh√≥m chat";

          // sender inbox (me) unread 0
          await upsertInboxForMe(key, {
            type:"group",
            groupId: gid,
            title: groupTitle,
            photoURL: "https://www.gravatar.com/avatar/?d=identicon&s=96",
            lastText: text,
            lastFrom: me.uid,
            lastFromName: me.displayName || "",
            lastTs: now
          });

          // each member (except sender) unread++
          for(const uid of members){
            if(uid === me.uid) continue;
            await incInboxForUser(uid, key, {
              type:"group",
              groupId: gid,
              title: groupTitle,
              photoURL: "https://www.gravatar.com/avatar/?d=identicon&s=96",
              lastText: text,
              lastFrom: me.uid,
              lastFromName: me.displayName || "",
              lastTs: now
            });
          }
        }

      }catch(e){
        toast("L·ªói g·ª≠i tin: " + (e.message || e));
      }
    }

    $("btnChatSend").onclick = sendMessage;
    chatInput.addEventListener("keydown",(e)=>{ if(e.key==="Enter") sendMessage(); });

    // ===== Auth =====
    $("btnLogin").onclick = ()=>signInWithPopup(auth, provider).catch(e=>toast(e.message));
    $("btnLogout").onclick = ()=>{ setSharingUI(false); signOut(auth); };
    $("btnToggleShare").onclick = ()=>setSharingUI(!sharing);

    // ===== UI state helpers =====
    function showLoading(){
      $("loadingScreen").classList.remove("hidden");
      $("loginScreen").classList.add("hidden");
      $("appScreen").classList.add("hidden");
    }
    function showLogin(){
      $("loadingScreen").classList.add("hidden");
      $("loginScreen").classList.remove("hidden");
      $("appScreen").classList.add("hidden");
    }
    function showApp(){
      $("loadingScreen").classList.add("hidden");
      $("loginScreen").classList.add("hidden");
      $("appScreen").classList.remove("hidden");
    }

    // ===== onAuth =====
    showLoading();
    let authResolved = false;

    onAuthStateChanged(auth, async (user)=>{
      me=user;

      // first resolve -> stop loading
      if(!authResolved){
        authResolved = true;
      }

      if(!me){
        showLogin();
        stopGeolocationWatch();
        detachAllFriendLocListeners();
        closeChat();
        if(unsubInbox){ try{unsubInbox();}catch{} unsubInbox=null; }
        if(myMarker){ map.removeLayer(myMarker); myMarker=null; }
        selectedFriends.clear();
        updateGroupBarUI();
        refreshNotiUI();
        return;
      }

      showApp();

      $("topName").textContent = me.displayName || "Me";
      $("topAvatar").src = safeAva(me.photoURL);
      $("userName").textContent = me.displayName || "";
      $("userEmail").textContent = me.email || "";
      $("userPhoto").src = safeAva(me.photoURL);

      userCache.set(me.uid,{displayName:me.displayName||"", email:me.email||"", photoURL:me.photoURL||""});

      await ensureUserDoc(me);
      await ensurePublicEmailIndex(me);

      // presence + lifecycle
      await startPresence();
      bindLifecycleHooks();

      // inbox
      listenInbox();

      // location
      startGeolocationWatch();

      // load share state (backup)
      const loc = await getDoc(doc(db,"locations",me.uid));
      if(loc.exists()) await setSharingUI(!!loc.data().sharing);
      else await setSharingUI(false);

      listenIncoming();
      listenFriends();
      listenGroups();

      refreshNotiUI();

      setTab("map");
      toast("Ch√†o " + (me.displayName || "b·∫°n"));
    });
  </script>

  <!-- ‚úÖ QUICK NOTE: n·∫øu group create b·ªã "Missing or insufficient permissions"
       -> c·∫ßn s·ª≠a Firestore rules. -->
</body>
</html>
